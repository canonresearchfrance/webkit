<!DOCTYPE html>
<script src='../resources/testharness.js'></script>
<script src='../resources/testharnessreport.js'></script>
<script src='resources/streams-utils.js'></script>
<script>

test0 = async_test('ReadableStream constructor should get a function as pull argument');
test0.step(function() {
     var rs =  new ReadableStream({ pull : 'potato'});
     setTimeout(test0.step_func(function() {
          assert_equals(rs.state, 'errored');
          test0.done();
      }), 50);
});

test1 = async_test('ReadableStream pull should be able to close a stream.');
test1.step(function() {
    var rs = new ReadableStream({
        pull: function(enqueue, close, error) {
            close()
        }
    });

    rs.ready.then(test1.step_func(function() {
        assert_equals(rs.state, 'closed');
        test1.done();
    }));
});

test2 = async_test('ReadableStream pull should be able to queue different objects.');
test2.step(function() {
    var objects = [
    { potato: 'Give me more!'},
    'test',
    1
    ];
    var rs = new ReadableStream({
        pull: function(enqueue, close, error) {
            enqueue(objects[0]);
            enqueue(objects[1]);
            enqueue(objects[2]);
            close()
        }
    });

    rs.closed.then(test2.step_func(function() {
        assert_equals(rs.state, 'closed');
        test2.done();
    }));
    rs.ready.then(test2.step_func(function() {
        assert_equals(rs.read(), objects[0]);
        assert_equals(rs.read(), objects[1]);
        assert_equals(rs.read(), objects[2]);
    }));
});

test3 = async_test('ReadableStream is able to enqueue lots of data in a single pull, making it available synchronously.');
test3.step(function() {
    var i = 0;
    const rs = new ReadableStream({
        pull: function(enqueue, close) {
            while (++i <= 10) {
                enqueue(i);
            }

            close();
        }
    });

    rs.ready.then(function() {
        const data = [];
        while (rs.state === 'readable') {
            data.push(rs.read());
        }

        assert_array_equals(data, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'got the expected 10 chunks');
        test3.done();
    });
});

test4 = async_test('ReadableStream does not call pull until previous pull\'s promise fulfills.');
test4.step(function() {
    var resolve;
    var returnedPromise;
    var timesCalled = 0;
    const rs = new ReadableStream({
        pull: function(enqueue) {
            ++timesCalled;
            enqueue(timesCalled);
            returnedPromise = new Promise(test4.step_func(function(r) { resolve = r; }));
            return returnedPromise;
        }
    });

    assert_equals(rs.state, 'waiting'); // Stream starts out waiting.

    rs.ready.then(test4.step_func(function() {
        assert_equals(rs.state, 'readable'); // Stream becomes readable (even before promise fulfills).
        assert_equals(timesCalled, 1); // Pull is not yet called a second time.
        assert_equals(rs.read(), 1); // read() returns enqueued value.

        setTimeout(test4.step_func(function() {
            assert_equals(timesCalled, 1); // After 30 ms, pull has still only been called once.

            resolve();

            returnedPromise.then(test4.step_func(function() {
                setTimeout(test4.step_func(function() {
                    assert_equals(timesCalled, 2); // After the promise is fulfilled, pull is called a second time.
                    assert_equals(rs.read(), 2); // read() returns the second enqueued value.
                    test4.done();
                }), 100);
            }));
        }), 30);
    }));
});

test5 = async_test('ReadableStream pull rejection makes stream errored.');
test5.step(function() {
    const theError = new Error('pull failure');
    const rs = new ReadableStream({
        pull: function() {
            return Promise.reject(theError);
        }
    });

    assert_equals(rs.state, 'waiting'); // Stream starts out waiting.

    rs.closed.then(
        function() {
            assert_unreached('.closed should not fulfill');
        },
        function(e) {
            assert_equals(e, theError, '.closed should reject with the error');
            test5.done();
        }
    );
});
</script>
