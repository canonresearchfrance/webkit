<!DOCTYPE html>
<script src='../resources/testharness.js'></script>
<script src='../resources/testharnessreport.js'></script>
<script>

test(function()
{
    var isStartCalled = false;
    var source =
    { start:
        function(enqueue, close, error) {
            assert_equals(this, source);
            assert_equals(typeof enqueue, 'function');
            assert_equals(typeof close, 'function');
            assert_equals(typeof error, 'function');
            assert_array_equals(Object.getOwnPropertyNames(close), ['name', 'length']);
            isStartCalled = true;
        }
    };
    var rs = new ReadableStream(source);
    assert_true(isStartCalled);
}, 'ReadableStream start should be called with the proper parameters');

test(function()
{
    mashedError = new Error('potato');
    assert_throws(mashedError, function() {
        var rs = new ReadableStream(
        { start:
            function(enqueue, close, error) {
                throw mashedError;
            }
        });
    });
}, 'ReadableStream start should be able to throw');

test(function() {
    assert_throws(new TypeError(), function() {
        new ReadableStream({ start: 'potato'});
    });
}, 'ReadableStream constructor should get a function as start argument');

test(function()
{
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            close();
        }
    });
    assert_equals(rs.state, 'closed');
}, 'ReadableStream start should be able to close the stream');

test(function()
{
    var closeFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
        }
    });
    assert_equals(rs.state, 'waiting');
    closeFunction();
    assert_equals(rs.state, 'closed');
}, 'Calling ReadableStream close function should transition synchronously to closed state');

test(function()
{
    var closeFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
        }
    });
    assert_equals(rs.state, 'waiting');
    closeFunction();
    assert_equals(rs.state, 'closed');
    closeFunction();
    assert_equals(rs.state, 'closed');
}, 'Calling ReadableStream close function several times should have no effect');

test1 = async_test('ReadableStream close should fulfill ready promise and then closed promise');
test1.step(function()
{
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            setTimeout(close,0);
        }
    });
    assert_equals(rs.state, 'waiting');

    var readyDone = false;
    rs.ready.then(test1.step_func(function(v) {
        readyDone = true;
        assert_equals(typeof v, 'undefined');
        assert_equals(rs.state, 'closed');
    }));

    rs.closed.then(test1.step_func(function(v) {
        assert_equals(readyDone, true);
        assert_equals(typeof v, 'undefined');
        assert_equals(rs.state, 'closed');
        test1.done();
    }));
});

test2 = async_test('ReadableStream close should fulfill ready asynchronously');
test2.step(function()
{
    var closeFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
        }
    });

    var readyDoneAsserted = false;
    var readyDone = false;
    closeFunction();
    assert_equals(rs.state, 'closed');
    rs.ready.then(test2.step_func(function() {
        readyDone = true;
        assert_true(readyDoneAsserted);
        test2.done();
    }));
    readyDoneAsserted = true;
    assert_false(readyDone);
});

test3 = async_test('ReadableStream close should fulfill closed promise asynchronously');
test3.step(function()
{
    var closeFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
        }
    });

    var closedDone = false;
    closeFunction();
    assert_equals(rs.state, 'closed');
    rs.closed.then(test3.step_func(function() {
        closedDone = true;
        assert_true(closedDoneAsserted);
        test3.done();
    }));
    closedDoneAsserted = true;
    assert_false(closedDone);
});

test4 = async_test('A closed ReadableStream should fulfill immediatly ready and closed promises');
test4.step(function()
{
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            close();
        }
    });

    var closedDone = false;
    rs.closed.then(test4.step_func(function() {
        closedDone = true;
    }));

    rs.ready.then(test4.step_func(function() {
        assert_true(closedDone);
        test4.done();
    }));
    assert_false(closedDone);
});

test5 = async_test('Calling ReadableStream close several times should not resolve several times closed or ready promises');
test5.step(function()
{
    var closeFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
        }
    });

    var counter = 0;
    rs.closed.then(test5.step_func(function() {
        counter++;
    }));
    rs.ready.then(test5.step_func(function() {
        counter++;
        assert_equals(counter, 1);
    }));
    closeFunction();
    closeFunction();

    setTimeout(test5.step_func(function() {
        test5.done();
    }), 50);
});

test6 = async_test('ReadableStream error should fulfill ready and closed promises');
test6.step(function()
{
    var passedError = new Error('aaugh!!');
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            assert_array_equals(Object.getOwnPropertyNames(error), ['name', 'length']);
            error(passedError);
        }
    });

    var readyDone = false;
    rs.ready.then(test6.step_func(function(v) {
        readyDone = true;
        assert_equals(typeof v, 'undefined');
        assert_equals(rs.state, 'errored');
    }));

    rs.closed.then(test6.step_func(function(v) {
        assert_unreached('closed promise should be rejected');
    }), test5.step_func(function(error) {
        assert_equals(readyDone, true);
        assert_equals(error, passedError);
        assert_equals(rs.state, 'errored');
        test6.done();
    }));
});

test7 = async_test('Calling ReadableStream error after close should have no effect');
test7.step(function()
{
    var closeFunction;
    var errorFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
            errorFunction = error;
        }
    });

    var counter = 0;
    rs.closed.then(test7.step_func(function() {
        counter++;
    }));
    rs.ready.then(test7.step_func(function() {
        counter++;
        assert_equals(counter, 1);
    }));

    assert_equals(rs.state, 'waiting');
    closeFunction();
    assert_equals(rs.state, 'closed');
    errorFunction();
    assert_equals(rs.state, 'closed');

    setTimeout(test7.step_func(function() {
        test7.done();
    }), 50);
});

test8 = async_test('Calling ReadableStream close after error should have no effect');
test8.step(function()
{
    var closeFunction;
    var errorFunction;
    var rs = new ReadableStream(
    { start:
        function(enqueue, close, error) {
            closeFunction = close;
            errorFunction = error;
        }
    });

    var counter = 0;
    rs.closed.then(test8.step_func(function() {
        counter++;
    }));
    rs.ready.then(test8.step_func(function() {
        counter++;
        assert_equals(counter, 1);
    }));

    assert_equals(rs.state, 'waiting');
    errorFunction();
    assert_equals(rs.state, 'errored');
    closeFunction();
    assert_equals(rs.state, 'errored');

    setTimeout(test8.step_func(function() {
        test8.done();
    }), 50);
});

</script>
