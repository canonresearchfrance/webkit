<!DOCTYPE html>
<script src='../resources/testharness.js'></script>
<script src='../resources/testharnessreport.js'></script>
<script src='resources/streams-utils.js'></script>
<script>
test1 = async_test('ReadableStream is able to enqueue lots of data in a single pull, making it available synchronously.');
test1.step(function() {
    var i = 0;
    const rs = new ReadableStream({
        pull: function(enqueue, close) {
            while (++i <= 10) {
                enqueue(i);
            }

            close();
        }
    });

    rs.ready.then(function() {
        const data = [];
        while (rs.state === 'readable') {
            data.push(rs.read());
        }

        assert_array_equals(data, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'got the expected 10 chunks');
        test1.done();
    });
});

test(function() {
    new ReadableStream({
        start: function(enqueue) {
            assert_equals(enqueue('hi'), true);
            assert_equals(enqueue('hey'), false);
            assert_equals(enqueue('whee'), false);
            assert_equals(enqueue('yo'), false);
            assert_equals(enqueue('sup'), false);
        }
    });
}, 'Default ReadableStream returns `false` for all but the first `enqueue` call');

test2 = async_test('ReadableStream continues returning `true` from `enqueue` if the data is read out of it in time.');
test2.step(function() {
    const rs = new ReadableStream({
        start: function(enqueue) {
            // Delay a bit so that the stream is successfully constructed and thus the `rs` variable references something.
            setTimeout(test2.step_func(function() {
                assert_equals(enqueue('foo'), true);
                assert_equals(rs.state, 'readable');
                assert_equals(rs.read(), 'foo');
                assert_equals(rs.state, 'waiting');

                assert_equals(enqueue('bar'), true);
                assert_equals(rs.state, 'readable');
                assert_equals(rs.read(), 'bar');
                assert_equals(rs.state, 'waiting');

                assert_equals(enqueue('baz'), true);
                assert_equals(rs.state, 'readable');
                assert_equals(rs.read(), 'baz');
                assert_equals(rs.state, 'waiting');
                test2.done();
            }), 0);
        },
        strategy: new CountQueuingStrategy(4)
    });
});

test3 = async_test('ReadableStream pull rejection makes stream errored.');
test3.step(function() {
    const theError = new Error('pull failure');
    const rs = new ReadableStream({
        pull: function() {
            return Promise.reject(theError);
        }
    });

    assert_equals(rs.state, 'waiting'); // Stream starts out waiting.

    rs.closed.then(
        function() {
            assert_unreached('.closed should not fulfill');
        },
        function(e) {
            assert_equals(e, theError, '.closed should reject with the error');
            test3.done();
        }
    );
});

test(function() {
    const rs = new ReadableStream({
        start: function(enqueue, close) {
            assert_equals(enqueue('a'), true);
            close();

            assert_throws(
                new TypeError(),
                function() {
                    enqueue('b');
                });
        },
        strategy: new CountQueuingStrategy(10)
    });

    assert_equals(rs.state, 'readable');
    assert_equals(rs.read(), 'a');
    assert_equals(rs.state, 'closed');
}, 'ReadableStream enqueue fails when the stream is draining.');

test(function() {
    var rs = new ReadableStream({
        start: function(enqueue, close) {
            close();

            assert_throws(
                new TypeError(),
                function() {
                    enqueue('a');
                });
        }
    });

    assert_equals(rs.state, 'closed');
}, 'ReadableStream enqueue fails when the stream is closed');

test(function() {
    var rs = new ReadableStream({
        start: function(enqueue, close, error) {
            error(new TypeError('woups'));

            assert_throws(
                new TypeError(),
                function() {
                    enqueue('a');
                });
        }
    });

    assert_equals(rs.state, 'errored');
}, 'ReadableStream enqueue fails when the stream is errored');

test(function() {
    new ReadableStream({
        start: function(enqueue) {
            assert_throws(new TypeError(), function() {enqueue('hi')});
        },
        strategy: {
            shouldApplyBackpressure: function(queueSize) {
                throw new TypeError("test");
            }
        }
    });
    new ReadableStream({
        start: function(enqueue) {
            assert_throws(new TypeError(), function() {enqueue('hi')});
        },
        strategy: {
            size: function(chunk) {
                throw new TypeError("test");
            }
        }
    });
    new ReadableStream({
        start: function(enqueue) {
            assert_throws(new TypeError(), function() {enqueue('hi')});
        },
        strategy: {
            size: function(chunk) {
                return "potato";
            }
        }
    });
}, 'Enqueue should throw in case of bad size or shouldApplyBackpressure functions');

</script>
